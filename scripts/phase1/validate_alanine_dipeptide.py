"""Validate alanine dipeptide φ/ψ samples by assessing topology and coverage.

The script expects the NumPy outputs generated by
``run_openmm_alanine_dipeptide.py`` and produces diagnostics required before
training VAEs in φ/ψ space:

* Ramachandran density plot (2D histogram)
* Persistence diagram (H₀/H₁) computed on the torus metric
* Barcode visualisation for persistent H₁ features
* Summary statistics (coverage in canonical basins, entropy, etc.)

All heavy lifting (MD, sampling) is assumed to be executed externally; this
script merely loads the saved arrays and generates analysis artifacts.
"""

from __future__ import annotations

import argparse
import json
import pathlib
from typing import Dict, Tuple

import matplotlib.pyplot as plt
import numpy as np
from scipy.stats import entropy

from src.tda.persistence import compute_persistence_diagrams


_MIT_RED = "#A31F34"
_MIT_GRAY = "#8A8B8C"
_TWO_PI = 2.0 * np.pi


def _wrap_angles(angles: np.ndarray) -> np.ndarray:
    return np.mod(angles, _TWO_PI)


def _plot_ramachandran(angles: np.ndarray, output: pathlib.Path) -> None:
    fig, ax = plt.subplots(figsize=(6, 5))
    h = ax.hist2d(
        angles[:, 0],
        angles[:, 1],
        bins=100,
        range=[[0, _TWO_PI], [0, _TWO_PI]],
        cmap="magma",
    )
    fig.colorbar(h[3], ax=ax, label="Density")
    ax.set_xlabel("ϕ (rad)")
    ax.set_ylabel("ψ (rad)")
    ax.set_title("Alanine dipeptide Ramachandran density")
    ax.set_xticks([0, np.pi, _TWO_PI])
    ax.set_xticklabels(["0", "π", "2π"])
    ax.set_yticks([0, np.pi, _TWO_PI])
    ax.set_yticklabels(["0", "π", "2π"])
    ax.set_xlim(0, _TWO_PI)
    ax.set_ylim(0, _TWO_PI)
    ax.set_aspect("equal")
    fig.tight_layout()
    output.parent.mkdir(parents=True, exist_ok=True)
    fig.savefig(output, dpi=300)
    plt.close(fig)


def _plot_persistence(diagrams, output_prefix: pathlib.Path) -> Tuple[int, float]:
    diag = diagrams.diagrams[0]
    h1 = diag.get(1, np.empty((0, 2)))

    fig, ax = plt.subplots(figsize=(5, 5))
    if diag.get(0) is not None:
        ax.scatter(diag[0][:, 0], diag[0][:, 1], label="H0", color=_MIT_GRAY, alpha=0.7, s=20)
    if h1.size:
        ax.scatter(h1[:, 0], h1[:, 1], label="H1", color=_MIT_RED, alpha=0.8, s=30)
    max_val = 1.0
    if diag:
        max_val = max(max_val, *(float(np.max(v)) for v in diag.values() if v.size))
    ax.plot([0, max_val], [0, max_val], linestyle="--", color="#333333", linewidth=1.0)
    ax.set_xlabel("Birth")
    ax.set_ylabel("Death")
    ax.set_title("Persistence diagram (alanine dipeptide)")
    ax.legend()
    fig.tight_layout()
    fig.savefig(output_prefix.with_name(output_prefix.name + "_pd.png"), dpi=300)
    plt.close(fig)

    fig, ax = plt.subplots(figsize=(5, 3))
    offset = 0
    for dim, points in diag.items():
        for birth, death in points:
            color = _MIT_RED if dim == 1 else _MIT_GRAY
            ax.hlines(offset, birth, death, colors=color, linewidth=2)
            offset += 1
        offset += 1
    ax.set_xlabel("Filtration value")
    ax.set_ylabel("Feature index")
    ax.set_title("Barcode (H0/H1)")
    fig.tight_layout()
    fig.savefig(output_prefix.with_name(output_prefix.name + "_barcode.png"), dpi=300)
    plt.close(fig)

    lifetimes = h1[:, 1] - h1[:, 0] if h1.size else np.array([])
    persistent_count = int(h1.shape[0])
    max_lifetime = float(lifetimes.max()) if lifetimes.size else 0.0
    return persistent_count, max_lifetime


def _basin_occupancy(angles: np.ndarray) -> Dict[str, float]:
    # Quadrants corresponding to α_R, C7eq, α_L basins (approximate ranges)
    regions = {
        "alpha_R": ((300 * np.pi / 180, 420 * np.pi / 180), (300 * np.pi / 180, 420 * np.pi / 180)),
        "C7eq": ((60 * np.pi / 180, 180 * np.pi / 180), (60 * np.pi / 180, 180 * np.pi / 180)),
        "alpha_L": ((120 * np.pi / 180, 240 * np.pi / 180), (120 * np.pi / 180, 240 * np.pi / 180)),
    }
    counts: Dict[str, float] = {}
    total = float(angles.shape[0])
    for name, ((phi_min, phi_max), (psi_min, psi_max)) in regions.items():
        mask = (
            (angles[:, 0] >= phi_min)
            & (angles[:, 0] < phi_max)
            & (angles[:, 1] >= psi_min)
            & (angles[:, 1] < psi_max)
        )
        counts[name] = float(mask.sum() / total)
    return counts


def validate_dataset(phi_psi_path: pathlib.Path, output_dir: pathlib.Path) -> None:
    angles = np.load(phi_psi_path)
    if angles.ndim != 2 or angles.shape[1] != 2:
        raise ValueError("phi_psi.npy must have shape (n_frames, 2).")
    angles = _wrap_angles(angles)

    output_dir.mkdir(parents=True, exist_ok=True)

    _plot_ramachandran(angles, output_dir / "ramachandran_density.png")

    diagrams = compute_persistence_diagrams(
        angles,
        homology_dims=(0, 1),
        backend="auto",
        center=False,
        geometry="dihedral",
    )
    h1_count, h1_max = _plot_persistence(diagrams, output_dir / "persistence")

    hist, _, _ = np.histogram2d(
        angles[:, 0],
        angles[:, 1],
        bins=60,
        range=[[0, _TWO_PI], [0, _TWO_PI]],
    )
    flat_hist = hist.flatten()
    flat_hist = flat_hist / flat_hist.sum() if flat_hist.sum() else flat_hist
    basin_stats = _basin_occupancy(angles)

    summary = {
        "n_frames": int(angles.shape[0]),
        "entropy_bits": float(entropy(flat_hist, base=2)),
        "h1_count": h1_count,
        "h1_max_persistence": h1_max,
        "basin_occupancy": basin_stats,
    }
    (output_dir / "summary.json").write_text(json.dumps(summary, indent=2))


def parse_args() -> argparse.Namespace:
    parser = argparse.ArgumentParser(description="Validate alanine dipeptide φ/ψ dataset")
    parser.add_argument("--phi-psi", type=pathlib.Path, required=True, help="Path to phi_psi.npy array")
    parser.add_argument(
        "--output-dir",
        type=pathlib.Path,
        default=pathlib.Path("results/alanine_dipeptide"),
        help="Directory to write validation artifacts",
    )
    return parser.parse_args()


def main() -> None:
    args = parse_args()
    validate_dataset(args.phi_psi, args.output_dir)


if __name__ == "__main__":  # pragma: no cover - CLI entry point only
    main()
